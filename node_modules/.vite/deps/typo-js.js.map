{
  "version": 3,
  "sources": ["browser-external:fs", "../../typo-js/typo.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/* globals chrome: false */\n/* globals __dirname: false */\n/* globals require: false */\n/* globals Buffer: false */\n/* globals module: false */\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */\nvar Typo;\n(function () {\n    \"use strict\";\n    /**\n     * Typo constructor.\n     *\n     * @param {string} [dictionary] The locale code of the dictionary being used. e.g.,\n     *                              \"en_US\". This is only used to auto-load dictionaries.\n     * @param {string} [affData]    The data from the dictionary's .aff file. If omitted\n     *                              and Typo.js is being used in a Chrome extension, the .aff\n     *                              file will be loaded automatically from\n     *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n     *                              In other environments, it will be loaded from\n     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n     * @param {string} [wordsData]  The data from the dictionary's .dic file. If omitted\n     *                              and Typo.js is being used in a Chrome extension, the .dic\n     *                              file will be loaded automatically from\n     *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n     *                              In other environments, it will be loaded from\n     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n     * @param {Object} [settings]   Constructor settings. Available properties are:\n     *                              {string} [dictionaryPath]: path to load dictionary from in non-chrome\n     *                              environment.\n     *                              {Object} [flags]: flag information.\n     *                              {boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n     *                              asynchronously.\n     *                              {Function} [loadedCallback]: Called when both affData and wordsData\n     *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n     *                              is the instantiated Typo object.\n     *\n     * @returns {Typo} A Typo object.\n     */\n    Typo = function (dictionary, affData, wordsData, settings) {\n        settings = settings || {};\n        this.dictionary = null;\n        this.rules = {};\n        this.dictionaryTable = {};\n        this.compoundRules = [];\n        this.compoundRuleCodes = {};\n        this.replacementTable = [];\n        this.flags = settings.flags || {};\n        this.memoized = {};\n        this.loaded = false;\n        var self = this;\n        var path;\n        // Loop-control variables.\n        var i, j, _len, _jlen;\n        if (dictionary) {\n            self.dictionary = dictionary;\n            // If the data is preloaded, just setup the Typo object.\n            if (affData && wordsData) {\n                setup();\n            }\n            // Loading data for browser extentions.\n            else if (typeof window !== 'undefined' && ((window.chrome && window.chrome.runtime) || (window.browser && window.browser.runtime))) {\n                var runtime = window.chrome && window.chrome.runtime ? window.chrome.runtime : window.browser.runtime;\n                if (settings.dictionaryPath) {\n                    path = settings.dictionaryPath;\n                }\n                else {\n                    path = \"typo/dictionaries\";\n                }\n                if (!affData)\n                    readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n                if (!wordsData)\n                    readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n            }\n            // Loading data for Node.js or other environments.\n            else {\n                if (settings.dictionaryPath) {\n                    path = settings.dictionaryPath;\n                }\n                else if (typeof __dirname !== 'undefined') {\n                    path = __dirname + '/dictionaries';\n                }\n                else {\n                    path = './dictionaries';\n                }\n                if (!affData)\n                    readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n                if (!wordsData)\n                    readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n            }\n        }\n        function readDataFile(url, setFunc) {\n            var response = self._readFile(url, null, settings === null || settings === void 0 ? void 0 : settings.asyncLoad);\n            if (settings === null || settings === void 0 ? void 0 : settings.asyncLoad) {\n                response.then(function (data) {\n                    setFunc(data);\n                });\n            }\n            else {\n                setFunc(response);\n            }\n        }\n        function setAffData(data) {\n            affData = data;\n            if (wordsData) {\n                setup();\n            }\n        }\n        function setWordsData(data) {\n            wordsData = data;\n            if (affData) {\n                setup();\n            }\n        }\n        function setup() {\n            self.rules = self._parseAFF(affData);\n            // Save the rule codes that are used in compound rules.\n            self.compoundRuleCodes = {};\n            for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n                var rule = self.compoundRules[i];\n                for (j = 0, _jlen = rule.length; j < _jlen; j++) {\n                    self.compoundRuleCodes[rule[j]] = [];\n                }\n            }\n            // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n            // will do the work of saving the list of words that are compound-only.\n            if (\"ONLYINCOMPOUND\" in self.flags) {\n                self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n            }\n            self.dictionaryTable = self._parseDIC(wordsData);\n            // Get rid of any codes from the compound rule codes that are never used\n            // (or that were special regex characters).  Not especially necessary...\n            for (i in self.compoundRuleCodes) {\n                if (self.compoundRuleCodes[i].length === 0) {\n                    delete self.compoundRuleCodes[i];\n                }\n            }\n            // Build the full regular expressions for each compound rule.\n            // I have a feeling (but no confirmation yet) that this method of\n            // testing for compound words is probably slow.\n            for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n                var ruleText = self.compoundRules[i];\n                var expressionText = \"\";\n                for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n                    var character = ruleText[j];\n                    if (character in self.compoundRuleCodes) {\n                        expressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n                    }\n                    else {\n                        expressionText += character;\n                    }\n                }\n                self.compoundRules[i] = new RegExp('^' + expressionText + '$', \"i\");\n            }\n            self.loaded = true;\n            if ((settings === null || settings === void 0 ? void 0 : settings.asyncLoad) && (settings === null || settings === void 0 ? void 0 : settings.loadedCallback)) {\n                settings.loadedCallback(self);\n            }\n        }\n        return this;\n    };\n    Typo.prototype = {\n        /**\n         * Loads a Typo instance from a hash of all of the Typo properties.\n         *\n         * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n         */\n        load: function (obj) {\n            for (var i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    this[i] = obj[i];\n                }\n            }\n            return this;\n        },\n        /**\n         * Read the contents of a file.\n         *\n         * @param {string} path The path (relative) to the file.\n         * @param {string} [charset=\"ISO8859-1\"] The expected charset of the file\n         * @param {boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n         *        files are read synchronously.\n         * @returns {string} The file data if async is false, otherwise a promise object. If running node.js, the data is\n         *          always returned.\n         */\n        _readFile: function (path, charset, async) {\n            var _a;\n            charset = charset || \"utf8\";\n            if (typeof XMLHttpRequest !== 'undefined') {\n                var req_1 = new XMLHttpRequest();\n                req_1.open(\"GET\", path, !!async);\n                (_a = req_1.overrideMimeType) === null || _a === void 0 ? void 0 : _a.call(req_1, \"text/plain; charset=\" + charset);\n                if (!!async) {\n                    var promise = new Promise(function (resolve, reject) {\n                        req_1.onload = function () {\n                            if (req_1.status === 200) {\n                                resolve(req_1.responseText);\n                            }\n                            else {\n                                reject(req_1.statusText);\n                            }\n                        };\n                        req_1.onerror = function () {\n                            reject(req_1.statusText);\n                        };\n                    });\n                    req_1.send(null);\n                    return promise;\n                }\n                else {\n                    req_1.send(null);\n                    return req_1.responseText;\n                }\n            }\n            else if (typeof require !== 'undefined') {\n                // Node.js\n                var fs = require(\"fs\");\n                try {\n                    if (fs.existsSync(path)) {\n                        return fs.readFileSync(path, charset);\n                    }\n                    else {\n                        console.log(\"Path \" + path + \" does not exist.\");\n                    }\n                }\n                catch (e) {\n                    console.log(e);\n                }\n                return '';\n            }\n            return '';\n        },\n        /**\n         * Parse the rules out from a .aff file.\n         *\n         * @param {string} data The contents of the affix file.\n         * @returns object The rules from the file.\n         */\n        _parseAFF: function (data) {\n            var rules = {};\n            var line, subline, numEntries, lineParts;\n            var i, j, _len, _jlen;\n            var lines = data.split(/\\r?\\n/);\n            for (i = 0, _len = lines.length; i < _len; i++) {\n                // Remove comment lines\n                line = this._removeAffixComments(lines[i]);\n                line = line.trim();\n                if (!line) {\n                    continue;\n                }\n                var definitionParts = line.split(/\\s+/);\n                var ruleType = definitionParts[0];\n                if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n                    var ruleCode = definitionParts[1];\n                    var combineable = definitionParts[2];\n                    numEntries = parseInt(definitionParts[3], 10);\n                    var entries = [];\n                    for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n                        subline = lines[j];\n                        lineParts = subline.split(/\\s+/);\n                        var charactersToRemove = lineParts[2];\n                        var additionParts = lineParts[3].split(\"/\");\n                        var charactersToAdd = additionParts[0];\n                        if (charactersToAdd === \"0\")\n                            charactersToAdd = \"\";\n                        var continuationClasses = this.parseRuleCodes(additionParts[1]);\n                        var regexToMatch = lineParts[4];\n                        var entry = {\n                            add: charactersToAdd\n                        };\n                        if (continuationClasses.length > 0)\n                            entry.continuationClasses = continuationClasses;\n                        if (regexToMatch !== \".\") {\n                            if (ruleType === \"SFX\") {\n                                entry.match = new RegExp(regexToMatch + \"$\");\n                            }\n                            else {\n                                entry.match = new RegExp(\"^\" + regexToMatch);\n                            }\n                        }\n                        if (charactersToRemove != \"0\") {\n                            if (ruleType === \"SFX\") {\n                                entry.remove = new RegExp(charactersToRemove + \"$\");\n                            }\n                            else {\n                                entry.remove = charactersToRemove;\n                            }\n                        }\n                        entries.push(entry);\n                    }\n                    rules[ruleCode] = { \"type\": ruleType, \"combineable\": (combineable === \"Y\"), \"entries\": entries };\n                    i += numEntries;\n                }\n                else if (ruleType === \"COMPOUNDRULE\") {\n                    numEntries = parseInt(definitionParts[1], 10);\n                    for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n                        line = lines[j];\n                        lineParts = line.split(/\\s+/);\n                        this.compoundRules.push(lineParts[1]);\n                    }\n                    i += numEntries;\n                }\n                else if (ruleType === \"REP\") {\n                    lineParts = line.split(/\\s+/);\n                    if (lineParts.length === 3) {\n                        this.replacementTable.push([lineParts[1], lineParts[2]]);\n                    }\n                }\n                else {\n                    // ONLYINCOMPOUND\n                    // COMPOUNDMIN\n                    // FLAG\n                    // KEEPCASE\n                    // NEEDAFFIX\n                    this.flags[ruleType] = definitionParts[1];\n                }\n            }\n            return rules;\n        },\n        /**\n         * Removes comments.\n         *\n         * @param {string} data A line from an affix file.\n         * @return {string} The cleaned-up line.\n         */\n        _removeAffixComments: function (line) {\n            // This used to remove any string starting with '#' up to the end of the line,\n            // but some COMPOUNDRULE definitions include '#' as part of the rule.\n            // So, only remove lines that begin with a comment, optionally preceded by whitespace.\n            if (line.match(/^\\s*#/)) {\n                return '';\n            }\n            return line;\n        },\n        /**\n         * Parses the words out from the .dic file.\n         *\n         * @param {string} data The data from the dictionary file.\n         * @returns HashMap The lookup table containing all of the words and\n         *                 word forms from the dictionary.\n         */\n        _parseDIC: function (data) {\n            data = this._removeDicComments(data);\n            var lines = data.split(/\\r?\\n/);\n            var dictionaryTable = {};\n            function addWord(word, rules) {\n                // Some dictionaries will list the same word multiple times with different rule sets.\n                if (!dictionaryTable.hasOwnProperty(word)) {\n                    dictionaryTable[word] = null;\n                }\n                if (rules.length > 0) {\n                    if (dictionaryTable[word] === null) {\n                        dictionaryTable[word] = [];\n                    }\n                    dictionaryTable[word].push(rules);\n                }\n            }\n            // The first line is the number of words in the dictionary.\n            for (var i = 1, _len = lines.length; i < _len; i++) {\n                var line = lines[i];\n                if (!line) {\n                    // Ignore empty lines.\n                    continue;\n                }\n                // The line format is one of:\n                //     word\n                //     word/flags\n                //     word/flags xx:abc yy:def\n                //     word xx:abc yy:def\n                // We don't use the morphological flags (xx:abc, yy:def) and we don't want them included\n                // in the extracted flags.\n                var just_word_and_flags = line.replace(/\\s.*$/, '');\n                // just_word_and_flags is definitely one of:\n                //     word\n                //     word/flags\n                var parts = just_word_and_flags.split('/', 2);\n                var word = parts[0];\n                // Now for each affix rule, generate that form of the word.\n                if (parts.length > 1) {\n                    var ruleCodesArray = this.parseRuleCodes(parts[1]);\n                    // Save the ruleCodes for compound word situations.\n                    if (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1) {\n                        addWord(word, ruleCodesArray);\n                    }\n                    for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n                        var code = ruleCodesArray[j];\n                        var rule = this.rules[code];\n                        if (rule) {\n                            var newWords = this._applyRule(word, rule);\n                            for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n                                var newWord = newWords[ii];\n                                addWord(newWord, []);\n                                if (rule.combineable) {\n                                    for (var k = j + 1; k < _jlen; k++) {\n                                        var combineCode = ruleCodesArray[k];\n                                        var combineRule = this.rules[combineCode];\n                                        if (combineRule) {\n                                            if (combineRule.combineable && (rule.type != combineRule.type)) {\n                                                var otherNewWords = this._applyRule(newWord, combineRule);\n                                                for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n                                                    var otherNewWord = otherNewWords[iii];\n                                                    addWord(otherNewWord, []);\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (code in this.compoundRuleCodes) {\n                            this.compoundRuleCodes[code].push(word);\n                        }\n                    }\n                }\n                else {\n                    addWord(word.trim(), []);\n                }\n            }\n            return dictionaryTable;\n        },\n        /**\n         * Removes comment lines and then cleans up blank lines and trailing whitespace.\n         *\n         * @param {string} data The data from a .dic file.\n         * @return {string} The cleaned-up data.\n         */\n        _removeDicComments: function (data) {\n            // I can't find any official documentation on it, but at least the de_DE\n            // dictionary uses tab-indented lines as comments.\n            // Remove comments\n            data = data.replace(/^\\t.*$/mg, \"\");\n            return data;\n        },\n        parseRuleCodes: function (textCodes) {\n            if (!textCodes) {\n                return [];\n            }\n            else if (!(\"FLAG\" in this.flags)) {\n                // The flag symbols are single characters\n                return textCodes.split(\"\");\n            }\n            else if (this.flags.FLAG === \"long\") {\n                // The flag symbols are two characters long.\n                var flags = [];\n                for (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n                    flags.push(textCodes.substr(i, 2));\n                }\n                return flags;\n            }\n            else if (this.flags.FLAG === \"num\") {\n                // The flag symbols are a CSV list of numbers.\n                return textCodes.split(\",\");\n            }\n            else if (this.flags.FLAG === \"UTF-8\") {\n                // The flags are single UTF-8 characters.\n                // @see https://github.com/cfinke/Typo.js/issues/57\n                return Array.from(textCodes);\n            }\n            else {\n                // It's possible that this fallback case will not work for all FLAG values,\n                // but I think it's more likely to work than not returning anything at all.\n                return textCodes.split(\"\");\n            }\n        },\n        /**\n         * Applies an affix rule to a word.\n         *\n         * @param {string} word The base word.\n         * @param {Object} rule The affix rule.\n         * @returns {string[]} The new words generated by the rule.\n         */\n        _applyRule: function (word, rule) {\n            var entries = rule.entries;\n            var newWords = [];\n            for (var i = 0, _len = entries.length; i < _len; i++) {\n                var entry = entries[i];\n                if (!entry.match || word.match(entry.match)) {\n                    var newWord = word;\n                    if (entry.remove) {\n                        newWord = newWord.replace(entry.remove, \"\");\n                    }\n                    if (rule.type === \"SFX\") {\n                        newWord = newWord + entry.add;\n                    }\n                    else {\n                        newWord = entry.add + newWord;\n                    }\n                    newWords.push(newWord);\n                    if (\"continuationClasses\" in entry) {\n                        for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n                            var continuationRule = this.rules[entry.continuationClasses[j]];\n                            if (continuationRule) {\n                                newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n                            }\n                            /*\n                            else {\n                                // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                                // I think the author mistakenly supplied lower-case rule codes instead\n                                // of upper-case.\n                            }\n                            */\n                        }\n                    }\n                }\n            }\n            return newWords;\n        },\n        /**\n         * Checks whether a word or a capitalization variant exists in the current dictionary.\n         * The word is trimmed and several variations of capitalizations are checked.\n         * If you want to check a word without any changes made to it, call checkExact()\n         *\n         * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n         *\n         * @param {string} aWord The word to check.\n         * @returns {boolean}\n         */\n        check: function (aWord) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            if (!aWord) {\n                return false;\n            }\n            // Remove leading and trailing whitespace\n            var trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n            if (this.checkExact(trimmedWord)) {\n                return true;\n            }\n            // The exact word is not in the dictionary.\n            if (trimmedWord.toUpperCase() === trimmedWord) {\n                // The word was supplied in all uppercase.\n                // Check for a capitalized form of the word.\n                var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n                if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n                    // Capitalization variants are not allowed for this word.\n                    return false;\n                }\n                if (this.checkExact(capitalizedWord)) {\n                    // The all-caps word is a capitalized word spelled correctly.\n                    return true;\n                }\n                if (this.checkExact(trimmedWord.toLowerCase())) {\n                    // The all-caps is a lowercase word spelled correctly.\n                    return true;\n                }\n            }\n            var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n            if (uncapitalizedWord !== trimmedWord) {\n                if (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n                    // Capitalization variants are not allowed for this word.\n                    return false;\n                }\n                // Check for an uncapitalized form\n                if (this.checkExact(uncapitalizedWord)) {\n                    // The word is spelled correctly but with the first letter capitalized.\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n         * Checks whether a word exists in the current dictionary.\n         *\n         * @param {string} word The word to check.\n         * @returns {boolean}\n         */\n        checkExact: function (word) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            var ruleCodes = this.dictionaryTable[word];\n            var i, _len;\n            if (typeof ruleCodes === 'undefined') {\n                // Check if this might be a compound word.\n                if (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n                    for (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n                        if (word.match(this.compoundRules[i])) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            else if (ruleCodes === null) {\n                // a null (but not undefined) value for an entry in the dictionary table\n                // means that the word is in the dictionary but has no flags.\n                return true;\n            }\n            else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n                for (i = 0, _len = ruleCodes.length; i < _len; i++) {\n                    if (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n         * Looks up whether a given word is flagged with a given flag.\n         *\n         * @param {string} word The word in question.\n         * @param {string} flag The flag in question.\n         * @return {boolean}\n         */\n        hasFlag: function (word, flag, wordFlags) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            if (flag in this.flags) {\n                if (typeof wordFlags === 'undefined') {\n                    wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n                }\n                if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n         * Returns a list of suggestions for a misspelled word.\n         *\n         * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n         * This suggestor is primitive, but it works.\n         *\n         * @param {string} word The misspelling.\n         * @param {number} [limit=5] The maximum number of suggestions to return.\n         * @returns {string[]} The array of suggestions.\n         */\n        alphabet: \"\",\n        suggest: function (word, limit) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            limit = limit || 5;\n            if (this.memoized.hasOwnProperty(word)) {\n                var memoizedLimit = this.memoized[word]['limit'];\n                // Only return the cached list if it's big enough or if there weren't enough suggestions\n                // to fill a smaller limit.\n                if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n                    return this.memoized[word]['suggestions'].slice(0, limit);\n                }\n            }\n            if (this.check(word))\n                return [];\n            // Check the replacement table.\n            for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n                var replacementEntry = this.replacementTable[i];\n                if (word.indexOf(replacementEntry[0]) !== -1) {\n                    var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n                    if (this.check(correctedWord)) {\n                        return [correctedWord];\n                    }\n                }\n            }\n            if (!this.alphabet) {\n                // Use the English alphabet as the default. Problematic, but backwards-compatible.\n                this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n                // Any characters defined in the affix file as substitutions can go in the alphabet too.\n                // Note that dictionaries do not include the entire alphabet in the TRY flag when it's there.\n                // For example, Q is not in the default English TRY list; that's why having the default\n                // alphabet above is useful.\n                if ('TRY' in this.flags) {\n                    this.alphabet += this.flags['TRY'];\n                }\n                // Plus any additional characters specifically defined as being allowed in words.\n                if ('WORDCHARS' in this.flags) {\n                    this.alphabet += this.flags['WORDCHARS'];\n                }\n                // Remove any duplicates.\n                var alphaArray = this.alphabet.split(\"\");\n                alphaArray.sort();\n                var alphaHash = {};\n                for (var i = 0; i < alphaArray.length; i++) {\n                    alphaHash[alphaArray[i]] = true;\n                }\n                this.alphabet = '';\n                for (var i in alphaHash) {\n                    this.alphabet += i;\n                }\n            }\n            var self = this;\n            /**\n             * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n             * The value of each entry is the number of unique ways that the resulting word can be made.\n             *\n             * @arg HashMap words A hash keyed by words (all with the value `true` to make lookups very quick).\n             * @arg boolean known_only Whether this function should ignore strings that are not in the dictionary.\n             */\n            function edits1(words, known_only) {\n                var rv = {};\n                var i, j, _iilen, _len, _jlen, _edit;\n                var alphabetLength = self.alphabet.length;\n                for (var word_1 in words) {\n                    for (i = 0, _len = word_1.length + 1; i < _len; i++) {\n                        var s = [word_1.substring(0, i), word_1.substring(i)];\n                        // Remove a letter.\n                        if (s[1]) {\n                            _edit = s[0] + s[1].substring(1);\n                            if (!known_only || self.check(_edit)) {\n                                if (!(_edit in rv)) {\n                                    rv[_edit] = 1;\n                                }\n                                else {\n                                    rv[_edit] += 1;\n                                }\n                            }\n                        }\n                        // Transpose letters\n                        // Eliminate transpositions of identical letters\n                        if (s[1].length > 1 && s[1][1] !== s[1][0]) {\n                            _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n                            if (!known_only || self.check(_edit)) {\n                                if (!(_edit in rv)) {\n                                    rv[_edit] = 1;\n                                }\n                                else {\n                                    rv[_edit] += 1;\n                                }\n                            }\n                        }\n                        if (s[1]) {\n                            // Replace a letter with another letter.\n                            var lettercase = (s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1)) ? 'uppercase' : 'lowercase';\n                            for (j = 0; j < alphabetLength; j++) {\n                                var replacementLetter = self.alphabet[j];\n                                // Set the case of the replacement letter to the same as the letter being replaced.\n                                if ('uppercase' === lettercase) {\n                                    replacementLetter = replacementLetter.toUpperCase();\n                                }\n                                // Eliminate replacement of a letter by itself\n                                if (replacementLetter != s[1].substring(0, 1)) {\n                                    _edit = s[0] + replacementLetter + s[1].substring(1);\n                                    if (!known_only || self.check(_edit)) {\n                                        if (!(_edit in rv)) {\n                                            rv[_edit] = 1;\n                                        }\n                                        else {\n                                            rv[_edit] += 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (s[1]) {\n                            // Add a letter between each letter.\n                            for (j = 0; j < alphabetLength; j++) {\n                                // If the letters on each side are capitalized, capitalize the replacement.\n                                var lettercase = (s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1)) ? 'uppercase' : 'lowercase';\n                                var replacementLetter = self.alphabet[j];\n                                if ('uppercase' === lettercase) {\n                                    replacementLetter = replacementLetter.toUpperCase();\n                                }\n                                _edit = s[0] + replacementLetter + s[1];\n                                if (!known_only || self.check(_edit)) {\n                                    if (!(_edit in rv)) {\n                                        rv[_edit] = 1;\n                                    }\n                                    else {\n                                        rv[_edit] += 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return rv;\n            }\n            function correct(word) {\n                var _a;\n                // Get the edit-distance-1 and edit-distance-2 forms of this word.\n                var ed1 = edits1((_a = {}, _a[word] = true, _a));\n                var ed2 = edits1(ed1, true);\n                // Sort the edits based on how many different ways they were created.\n                var weighted_corrections = ed2;\n                for (var ed1word in ed1) {\n                    if (!self.check(ed1word)) {\n                        continue;\n                    }\n                    if (ed1word in weighted_corrections) {\n                        weighted_corrections[ed1word] += ed1[ed1word];\n                    }\n                    else {\n                        weighted_corrections[ed1word] = ed1[ed1word];\n                    }\n                }\n                var i, _len;\n                var sorted_corrections = [];\n                for (i in weighted_corrections) {\n                    if (weighted_corrections.hasOwnProperty(i)) {\n                        if (self.hasFlag(i, \"PRIORITYSUGGEST\")) {\n                            // We've defined a new affix rule called PRIORITYSUGGEST, indicating that\n                            // if this word is in the suggestions list for a misspelled word, it should\n                            // be given priority over other suggestions.\n                            //\n                            // Add a large number to its weight to push it to the top of the list.\n                            // If multiple priority suggestions are in the list, they'll still be ranked\n                            // against each other, but they'll all be above non-priority suggestions.\n                            weighted_corrections[i] += 1000;\n                        }\n                        sorted_corrections.push([i, weighted_corrections[i]]);\n                    }\n                }\n                function sorter(a, b) {\n                    var a_val = a[1];\n                    var b_val = b[1];\n                    if (a_val < b_val) {\n                        return -1;\n                    }\n                    else if (a_val > b_val) {\n                        return 1;\n                    }\n                    // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n                    return b[0].localeCompare(a[0]);\n                }\n                sorted_corrections.sort(sorter).reverse();\n                var rv = [];\n                var capitalization_scheme = \"lowercase\";\n                if (word.toUpperCase() === word) {\n                    capitalization_scheme = \"uppercase\";\n                }\n                else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n                    capitalization_scheme = \"capitalized\";\n                }\n                var working_limit = limit;\n                for (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {\n                    if (\"uppercase\" === capitalization_scheme) {\n                        sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n                    }\n                    else if (\"capitalized\" === capitalization_scheme) {\n                        sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n                    }\n                    if (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) === -1) {\n                        rv.push(sorted_corrections[i][0]);\n                    }\n                    else {\n                        // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n                        working_limit++;\n                    }\n                }\n                return rv;\n            }\n            this.memoized[word] = {\n                'suggestions': correct(word),\n                'limit': limit\n            };\n            return this.memoized[word]['suggestions'];\n        }\n    };\n})();\n// Support for use as a node.js module.\nif (typeof module !== 'undefined') {\n    module.exports = Typo;\n}\n"],
  "mappings": "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",
  "names": ["word", "i", "_len"]
}
